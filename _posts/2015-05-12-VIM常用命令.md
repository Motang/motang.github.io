---
layout: post
title: Vim常用命令
category: tools
tags: [Vim常用命令]
comments: true
share: true
---
## 目录 ##

* Table of Contents
{:toc}

## 1. 介绍 ##
记录linux中vim的常用命令

## 2. 常用命令 ##
对于入门vim基本命令可以参考 简明 Vim 练级攻略，以下是本人关于移动光标、插入/修改、删除、复制、粘帖、撤销和恢复等常用命令

### 2.1 移动光标

对于在行内移动，通过使用f/F + 字符来移动到特定的字符，然后再使用. 来重复执行命令；f表示向前移动，F表示向后移动。如果想直接移动到行首或行尾，使用^或$
对于在多行移动，就有多种选择：第一种是通过gg，G，行数 + G指定行数来移动，gg表示移动文件的第一行，G表示移动文件的最后一行，行数 + G表示移动到特定的行。第二种就是通过正则搜索的方式来移动，/string表示正向查找，?string表示反向查找，n查找下一个匹配的结果，N表示上一个匹配的结果，按up/down可以浏览搜索历史。第三种就是使用标记来移动，m + {a-z}标记位置(适用于单个文件，如果是多个文件，使用大写字母{A-Z})，`{mark}移动到标记位置的列，'{mark} 移动到标记位置的行首，还有一些特殊的标记，'表示跳转前光标的位置

### 2.2 选择文本
v不规则选择
V按行选择
Ctrl + V按列选择

### 2.3 插入/修改
i在当前字符前面插入
I在行首插入
a在当前字符后面插入
A在行尾插入
o在当前行的下一行插入
O在当前行的上一行插入

r更改当前的字符
R更改多个字符
cw/caw更改单词
cf + 字符更改从当前字符到指定字符
c$更改从当前字符到行尾
cc更改整行

### 2.4 删除
x删除字符
df + 字符删除从当前字符到指定字符
dw/daw删除单词
d$删除从当前光标到行尾
dd删除一行

### 2.5 剪切与粘帖
dd + pdelete一行，然后放在当前光标下方
dd + Pdelete一行，然后放在当前光标上方
dw + p delete单词，然后放在当前光标后面
dw + P delete单词，然后放在当前光标前面
p/P可接受计数前缀，重复粘贴

### 2.6 复制
yw复制单词
yf复制从当前字符到指定字符
y$复制当前光标到行尾
yy复制整行

### 2.7 撤销和恢复
u撤销
ctrl + r重做

### 2.8 重复操作
数字+action表示执行某个操作多少次
.重复上一个操作

### 2.9 宏录制
q + 寄存器(a-z)开始录制
录制动作
q停止录制
@ + 寄存器 / @@replay被录制的宏

## 3. Linux环境获取系统性能数据 ##

### 3.1 CPU利用率
/proc/stat文件里包含系统cpu使用情况，2-8列对应的CPU消耗含义是用户态消耗(user)、用户态nice消耗(nice)、内核态消耗(sys)、空闲时间(idle)、等待IO消耗(iowait)、硬件中断消耗(hardirq)、软中断消耗(softirq)。（man proc）

```
$ cat /proc/stat
cpu  2339504870 2641995 716723851 70316975284 7219566 328971 304057999 0 0
cpu0 211214357 275710 57674236 2778331292 3688175 10421 12279511 0 0
cpu1 140100049 278788 47142039 2857686940 180452 32028 14960093 0 0
...
```
要计算t1~t2时间内系统的cpu利用率，需要在t1、t2时刻分别采集cpu使用信息

```
t1_all = t1(user + nice + sys + idle + iowait + hardirq + sortirq)
t1_used = t1(user + nice + sys + iowait + hardirq + sortirq)
t2_all = t2(user + nice + sys + idle + iowait + hardirq + sortirq
t2_used = t2(user + nice + sys + iowait + hardirq + sortirq)

cpu_usage = (t2_used - t1_used) / (t2_all - t1_all)
```

### 3.2 进程CPU利用率

/proc/$pid/stat文件里包含某个进程的cpu使用信息，14、15、16、17列对应进程用户态消耗(user)、内核态消耗(sys)、用户态等待子进程的消耗(user_child)、内核态等待子进程的消耗(sys_child)。

```
$cat /proc/24076/stat
24076 (redis-server) S 1 24076 24076 0 -1 4202560 5755 147 0 0 1864 3298 0 0 20 0 3 0 70238536 159555584 5145 18446744073709551615 1 1 0 0 0 0 0 4097 17610 18446744073709551615 0 0 17 4 0 0 0 0 0
```
t1、t2时刻分别采集/proc/stat、/proc/$pid/stat，获取总的cpu消耗，以及进程的cpu消耗

```
t1_all = t1(user + nice + sys + idle + iowait + hardirq + sortirq)
t1_pid = t1(user + sys + user_child + sys_child)
t2_all = t2(user + nice + sys + idle + iowait + hardirq + sortirq)
t2_pid = t2(user + sys + user_child + sys_child)

pid_cpu_usage = (t2_pid - t1_pid) / (t2_all - t1_all)
```

### 3.3 内存利用率
/proc/meminfo文件里包含系统内存使用信息

```
$ cat /proc/meminfo
MemTotal:       198450624 kB
MemFree:        184950332 kB

mem_usage = 1 - MemFree / MemTotal
```

### 3.4 系统load
/proc/uptime的前3列包含了最近1min、5min、15min系统的平均load（正在运行或等待IO的进程数，进程state为R或D）

```
$cat /proc/loadavg
0.02 0.09 0.08 1/2362 855
```

### 3.5 网卡流量信息
/proc/net/dev包含所有网卡的流量信息，第1、2、10、11列分别代表网卡当前接受字节数（recv_bytes）、接受包个数(recv_packets)、发送字节数(send_bytes)、发送个数(send_packets)。

```
$cat /proc/net/dev
Inter-|   Receive                                                |  Transmit
 face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls     carrier compressed
 lo:25047448261 37947893    0    0    0     0          0         0 25047448261 37947893    0    0    0     0       0          0
 eth0:2566932970457 7620547348    0    0    2     0          0     62732 728662220296 6145797287    0    0    0     0       0          0
 eth1:2023304550582 7268848253    0    0    0     0          0     77924 742443231982 6129090809    0    0    0     0       0          0
```
t1~t2时间内的平均流量为

```
avg_recv_bytes = (t2_recv_bytes - t1_recv_bytes) / (t2 - t1)
avg_send_bytes = (t2_send_bytes - t1_send_bytes) / (t2 - t1)
```

### 3.6 磁盘（文件系统）空间信息
通过statfs系统调用可获取当前文件系统的空间占用情况

```
struct statfs {
    long    f_type;     /* type of file system (see below) */
    long    f_bsize;    /* optimal transfer block size */
    long    f_blocks;   /* total data blocks in file system */
    long    f_bfree;    /* free blocks in fs */
    long    f_bavail;   /* free blocks avail to non-superuser */
    ...
};

disk_usage = 1 - f_bfree / f_blocks
```

### 3.7 磁盘读写信息
/proc/diskstats包含磁盘的IO信息，第4-9列分别为当前磁盘读次数(read)，磁盘读扇区数(read_sec)、磁盘读毫秒数(read_ms)、磁盘写次数(write)、磁盘写扇区数(write_sec)、磁盘写毫秒数(write_ms)。

```
$cat /proc/diskstats
8       4 sda4 3 0 12 8 0 0 0 0 0 8 8
8       5 sda5 87928 55284 2842138 17349 1230958 7932106 73380432 4931382 0 503343 4947504
8      16 sdb 393 35 3418 37 17 2 152 0 0 37 37
8      32 sdc 788 114 10690 10132 14550036 226568635 1929026928 623148463 0 4917530 623154797
```
t1~t2时间内磁盘平均读写次数、扇区数、IO利用率计算如下

```
avg_read = (t2_read - t1_read) / (t2 - t1)
avg_read_sec = (t2_read_sec - t1_read_sec) / (t2 - t1)
avg_write = (t2_write - t1_write) / (t2 - t1)
avg_write_sec = (t2_write_sec - t1_write_sec) / (t2 - t1)
io_util = (t2_read_ms + t2_write_ms - t1_read_ms - t1_write_ms) / (t2 - t1) (t1~t2时间段内IO的时间百分比）
```
